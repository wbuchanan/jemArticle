------------------------------------------------------------------------------------------------------------------------------------
      name:  jemlog
       log:  /Users/billy/Desktop/Articles/JEM/src/logs/JEMlogs.txt
  log type:  text
 opened on:   3 Dec 2017, 11:09:28

. 
. import excel using ../data/raw.xlsx, clear first case(l)

. 
. qui: replace porf = cond(porf == "P", "1", cond(porf == "F", "0", ""))

. rename (inst1 studno studscor porf itemno itemjud)(inst1 stdid score pred        ///   
> itemid itemdiff)

. qui: destring pred, replace

. la def passfail 0 "Fail" 1 "Pass", modify

. la val pred passfail

. qui: g byte tchid = cond(inst1 == "A", 1, cond(inst1 == "B", 2, 3))

. drop inst1

. mata:
------------------------------------------------- mata (type end to exit) ----------------------------------------------------------
:         angoff = select(st_data(., (4..6)), rowmissing(st_data(., (4..6))) :== 0)

:         cutscores = J(1, 4, .)

:         for( i = 1; i <= 3; i++) {
>                 cutscores[1, i] = colsum(select(angoff[., 2], angoff[., 3] :== i))
>         }

:         cutscores[1, 4] = rowsum(cutscores[1, 1..3]) / 3

:         st_matrix("cutscores", cutscores)

:         // Rater 1 ratings
:         r1 = select(angoff[., (1..2)], angoff[., 3] :== 1)

:         r2 = select(angoff[., (1..2)], angoff[., 3] :== 2)

:         r3 = select(angoff[., (1..2)], angoff[., 3] :== 3)

:         mu1 = mean(r1[., 2])

:         mu2 = mean(r2[., 2])

:         mu3 = mean(r3[., 2])

:         sigma1 = sqrt(variance(r1[., 2]))

:         sigma2 = sqrt(variance(r2[., 2]))

:         sigma3 = sqrt(variance(r3[., 2]))

:         items = J(3, 13, .)

:         for(i = 1; i <= 13; i++) {
>                 items[1, i] = r1[i, 2]
>                 items[2, i] = r2[i, 2]
>                 items[3, i] = r3[i, 2]
>         }

:         muitems = mean(items)

:         sigmaitems = J(1, 13, .)

:         for(i = 1; i <= 13; i++) {
>                 sigmaitems[1, i] = sqrt(variance(items[., i]))
>         }

:         itemsummary = (muitems', sigmaitems')

:         ratersummary = (mu1, sigma1 \ mu2, sigma2 \ mu3, sigma3)

:         st_matrix("items", itemsummary)

:         st_matrix("raters", ratersummary)

: end
------------------------------------------------------------------------------------------------------------------------------------

. 
. loc istem1 "Something"

. loc istem2 "else"

. loc istem3 "other"

. loc istem4 "a"

. loc istem5 "b"

. loc istem6 "c"

. loc istem7 "d"

. loc istem8 "e"

. loc istem9 "f"

. loc istem10 "g"

. loc istem11 "h"

. loc istem12 "i"

. loc istem13 "j"

. 
. 
. forv i = 1/13 {
  2.         loc irownames `"`irownames' "Item `i' : `istem`i''""'
  3.         //loc irownames `irownames' Item`i'
. }

. 
. loc colnms Mean "Std Dev"

. mat rownames items = `irownames'

. mat rownames raters = Instructor1 Instructor2 Instructor3

. mat colnames items = `colnms'

. mat colnames raters = `colnms'

. mat li items

items[13,2]
                        Mean    Std Dev
Item 1 :Something         .8         .1
     Item 2 :else  .58333333  .18929694
    Item 3 :other         .6         .1
        Item 4 :a  .46666667   .2081666
        Item 5 :b  .53333333  .23094011
        Item 6 :c        .65  .25980762
        Item 7 :d        .55  .18027756
        Item 8 :e        .45  .21794495
        Item 9 :f         .5         .2
       Item 10 :g  .43333333  .23094011
       Item 11 :h         .5         .2
       Item 12 :i  .48333333  .20207259
       Item 13 :j        .45  .30413813

. mat li raters

raters[3,2]
                  Mean    Std Dev
Instructor1  .38461538   .1328919
Instructor2  .49230769   .1754116
Instructor3  .73846154  .07679476

. 
end of do-file

. estout m(raters), mlabels(, none) ti("Table 1. Average and Standard Deviation of Raters' Ratings")

Table 1. Average and Standard Deviation of Raters' Ratings
--------------------------------------
                     Mean      Std Dev
--------------------------------------
Instructor1      .3846154     .1328919
Instructor2      .4923077     .1754116
Instructor3      .7384615     .0767948
--------------------------------------

. estout m(items), mlabels(, none) ti("Table 2. Average and Standard Deviation of Item Ratings") 

Table 2. Average and Standard Deviation of Item Ratings
--------------------------------------
                     Mean      Std Dev
--------------------------------------
Item 1                                
Something              .8           .1
--------------------------------------
Item 2                                
else             .5833333     .1892969
--------------------------------------
Item 3                                
other                  .6           .1
--------------------------------------
Item 4                                
a                .4666667     .2081666
--------------------------------------
Item 5                                
b                .5333333     .2309401
--------------------------------------
Item 6                                
c                     .65     .2598076
--------------------------------------
Item 7                                
d                     .55     .1802776
--------------------------------------
Item 8                                
e                     .45     .2179449
--------------------------------------
Item 9                                
f                      .5           .2
--------------------------------------
Item 10                               
g                .4333333     .2309401
--------------------------------------
Item 11                               
h                      .5           .2
--------------------------------------
Item 12                               
i                .4833333     .2020726
--------------------------------------
Item 13                               
j                     .45     .3041381
--------------------------------------

. h ascii

. ascii
33  ! 34  " 35  # 36  $ 37  % 38  & 39  ' 40  ( 41  ) 42  * 43  + 44  , 45  - 46  . 47  / 48  0 49  1 50  2 51  3 52  4 53  5 54  6
55  7 56  8 57  9 58  : 59  ; 60  < 61  = 62  > 63  ? 64  @ 65  A 66  B 67  C 68  D 69  E 70  F 71  G 72  H 73  I 74  J 75  K 76  L
77  M 78  N 79  O 80  P 81  Q 82  R 83  S 84  T 85  U 86  V 87  W 88  X 89  Y 90  Z 91  [ 92  \ 93  ] 94  ^ 95  _ 96  ` 97  a 98  b
99  c 100 d 101 e 102 f 103 g 104 h 105 i 106 j 107 k 108 l 109 m 110 n 111 o 112 p 113 q 114 r 115 s 116 t 117 u 118 v 119 w 120 x
121 y 122 z 123 { 124 | 125 } 126 ~ 127  128 ‚Ç¨ 129 ¬Å 130 ‚Äö 131 ∆í 132 ‚Äû 133 ‚Ä¶ 134 ‚Ä† 135 ‚Ä° 136 ÀÜ 137 ‚Ä∞ 138 ≈† 139 ‚Äπ 140 ≈í 141 ¬ç 142 ≈Ω
143 ¬è 144 ¬ê 145 ‚Äò 146 ‚Äô 147 ‚Äú 148 ‚Äù 149 ‚Ä¢ 150 ‚Äì 151 ‚Äî 152 Àú 153 ‚Ñ¢ 154 ≈° 155 ‚Ä∫ 156 ≈ì 157 ¬ù 158 ≈æ 159 ≈∏ 160 ¬† 161 ¬° 162 ¬¢ 163 ¬£ 164 ¬§
165 ¬• 166 ¬¶ 167 ¬ß 168 ¬® 169 ¬© 170 ¬™ 171 ¬´ 172 ¬¨ 173 ¬≠ 174 ¬Æ 175 ¬Ø 176 ¬∞ 177 ¬± 178 ¬≤ 179 ¬≥ 180 ¬¥ 181 ¬µ 182 ¬∂ 183 ¬∑ 184 ¬∏ 185 ¬π 186 ¬∫
187 ¬ª 188 ¬º 189 ¬Ω 190 ¬æ 191 ¬ø 192 √Ä 193 √Å 194 √Ç 195 √É 196 √Ñ 197 √Ö 198 √Ü 199 √á 200 √à 201 √â 202 √ä 203 √ã 204 √å 205 √ç 206 √é 207 √è 208 √ê
209 √ë 210 √í 211 √ì 212 √î 213 √ï 214 √ñ 215 √ó 216 √ò 217 √ô 218 √ö 219 √õ 220 √ú 221 √ù 222 √û 223 √ü 224 √† 225 √° 226 √¢ 227 √£ 228 √§ 229 √• 230 √¶
231 √ß 232 √® 233 √© 234 √™ 235 √´ 236 √¨ 237 √≠ 238 √Æ 239 √Ø 240 √∞ 241 √± 242 √≤ 243 √≥ 244 √¥ 245 √µ 246 √∂ 247 √∑ 248 √∏ 249 √π 250 √∫ 251 √ª 252 √º
253 √Ω 254 √æ 255 √ø
. di char(248)
¯

. di char(247)
˜

. di char(149)
ï

. di char(111)
o

. di {c 247}
invalid syntax
r(198);

. di as smcl {c 247}
invalid syntax
r(198);

. di in smcl {c 247}
invalid syntax
r(198);

. di in smcl "{c 247}"
√∑

. di in smcl "{c 248}"
√∏

. ascii
33  ! 34  " 35  # 36  $ 37  % 38  & 39  ' 40  ( 41  ) 42  * 43  + 44  , 45  - 46  . 47  / 48  0 49  1 50  2 51  3 52  4 53  5 54  6
55  7 56  8 57  9 58  : 59  ; 60  < 61  = 62  > 63  ? 64  @ 65  A 66  B 67  C 68  D 69  E 70  F 71  G 72  H 73  I 74  J 75  K 76  L
77  M 78  N 79  O 80  P 81  Q 82  R 83  S 84  T 85  U 86  V 87  W 88  X 89  Y 90  Z 91  [ 92  \ 93  ] 94  ^ 95  _ 96  ` 97  a 98  b
99  c 100 d 101 e 102 f 103 g 104 h 105 i 106 j 107 k 108 l 109 m 110 n 111 o 112 p 113 q 114 r 115 s 116 t 117 u 118 v 119 w 120 x
121 y 122 z 123 { 124 | 125 } 126 ~ 127  128 ‚Ç¨ 129 ¬Å 130 ‚Äö 131 ∆í 132 ‚Äû 133 ‚Ä¶ 134 ‚Ä† 135 ‚Ä° 136 ÀÜ 137 ‚Ä∞ 138 ≈† 139 ‚Äπ 140 ≈í 141 ¬ç 142 ≈Ω
143 ¬è 144 ¬ê 145 ‚Äò 146 ‚Äô 147 ‚Äú 148 ‚Äù 149 ‚Ä¢ 150 ‚Äì 151 ‚Äî 152 Àú 153 ‚Ñ¢ 154 ≈° 155 ‚Ä∫ 156 ≈ì 157 ¬ù 158 ≈æ 159 ≈∏ 160 ¬† 161 ¬° 162 ¬¢ 163 ¬£ 164 ¬§
165 ¬• 166 ¬¶ 167 ¬ß 168 ¬® 169 ¬© 170 ¬™ 171 ¬´ 172 ¬¨ 173 ¬≠ 174 ¬Æ 175 ¬Ø 176 ¬∞ 177 ¬± 178 ¬≤ 179 ¬≥ 180 ¬¥ 181 ¬µ 182 ¬∂ 183 ¬∑ 184 ¬∏ 185 ¬π 186 ¬∫
187 ¬ª 188 ¬º 189 ¬Ω 190 ¬æ 191 ¬ø 192 √Ä 193 √Å 194 √Ç 195 √É 196 √Ñ 197 √Ö 198 √Ü 199 √á 200 √à 201 √â 202 √ä 203 √ã 204 √å 205 √ç 206 √é 207 √è 208 √ê
209 √ë 210 √í 211 √ì 212 √î 213 √ï 214 √ñ 215 √ó 216 √ò 217 √ô 218 √ö 219 √õ 220 √ú 221 √ù 222 √û 223 √ü 224 √† 225 √° 226 √¢ 227 √£ 228 √§ 229 √• 230 √¶
231 √ß 232 √® 233 √© 234 √™ 235 √´ 236 √¨ 237 √≠ 238 √Æ 239 √Ø 240 √∞ 241 √± 242 √≤ 243 √≥ 244 √¥ 245 √µ 246 √∂ 247 √∑ 248 √∏ 249 √π 250 √∫ 251 √ª 252 √º
253 √Ω 254 √æ 255 √ø
. di in smcl "{c 149}"
‚Ä¢

. loc dot `: di in smcl "{c 149}"'
in not found

. loc dot `"`: di in smcl "{c 149}"'"'
in not found

. loc dot `"`: di _char(149)'"'

. di `"`dot'"'
¬ï

. di _char(149)
¬ï

. di _char(247)
√∑

. loc div `: di _char(247)'

. di `"`div'"'
√∑

. do "/var/folders/px/cg4_66j52pvfn2z7pbjvb5d80000gn/T//SD01075.000000"

. 
. // Stores division character from extended ascii range in a local macro
. loc div `: di _char(247)'

. 
. // Loads the data set containing the predicted pass/fail indicator, observed
. // scores, and item judgments
. import excel using ../data/raw.xlsx, clear first case(l)

. 
. // Recodes the predicted pass/fail indicator with a numeric value
. qui: replace porf = cond(porf == "P", "1", cond(porf == "F", "0", ""))

. 
. // Renames the variables from the original source
. rename (inst1 studno studscor porf itemno itemjud)(inst1 stdid score pred        ///   
> itemid itemdiff)

. 
. // Recasts the predicted pass/fail indicator as a numeric type
. qui: destring pred, replace

. 
. // Defines a pass/fail value label (masking) that attributes the labels with the
. // numeric values
. la def passfail 0 "Fail" 1 "Pass", modify

. 
. // Applies the passfail label to the values in the pred variable/column
. la val pred passfail

. 
. // Creates a numeric teacher ID (needed because Mata does not include objects 
. // that store text and numeric data in a single data frame like object
. qui: g byte tchid = cond(inst1 == "A", 1, cond(inst1 == "B", 2, 3))

. 
. // Starts the Mata interpreter
. mata:
------------------------------------------------- mata (type end to exit) ----------------------------------------------------------
: 
:         // Creates the object named angoff by selecting all of the non-missing values
:         // across the last three columns/variables in the data set (e.g., the item 
:         // judgments from the three instructors)
:         angoff = select(st_data(., (4..6)), rowmissing(st_data(., (4..6))) :== 0)

:         
:         // Defines a container object to store the individual instructor cutscores 
:         // and the cutscore defined by averaging over these ratings
:         cutscores = J(1, 4, .)

:         
:         // Loop over the values that identify individual instructors
:         for( i = 1; i <= 3; i++) {
>         
>                 // Replace the corresponding columns in the cutscores matrix with the 
>                 // sum of the item probabilities for each instructor
>                 cutscores[1, i] = colsum(select(angoff[., 2], angoff[., 3] :== i))
>                 
>         } // End of Loop

:         
:         // Averages the sum of the item probabilities across the instructors
:         cutscores[1, 4] = rowsum(cutscores[1, 1..3]) / 3

:         
:         // Creates a Stata matrix named cutscores that contains these values
:         st_matrix("cutscores", cutscores)

:         
:         // Creates an object to store the ratings from rater # 1
:         r1 = select(angoff[., (1..2)], angoff[., 3] :== 1)

:         
:         // Creates an object to store the ratings from rater # 2
:         r2 = select(angoff[., (1..2)], angoff[., 3] :== 2)

:         
:         // Creates an object to store the ratings from rater # 3
:         r3 = select(angoff[., (1..2)], angoff[., 3] :== 3)

:         
:         // Average item probability for instructor # 1
:         mu1 = mean(r1[., 2])

:         
:         // Average item probability for instructor # 2
:         mu2 = mean(r2[., 2])

:         
:         // Average item probability for instructor # 3
:         mu3 = mean(r3[., 2])

:         
:         // Standard deviation of item probabilities for instructor # 1
:         sigma1 = sqrt(variance(r1[., 2]))

:         
:         // Standard deviation of item probabilities for instructor # 2
:         sigma2 = sqrt(variance(r2[., 2]))

:         
:         // Standard deviation of item probabilities for instructor # 3
:         sigma3 = sqrt(variance(r3[., 2]))

:         
:         // Creates a container matrix to store the probabilities across columns
:         items = J(3, 13, .)

:         
:         // Container to store the standard deviations of each item
:         sigmaitems = J(1, 13, .)

:         
:         // Loops over the item indexes 
:         for(i = 1; i <= 13; i++) {
>         
>                 // Populates the ith column in the 1st row (Instructor 1) with the 
>                 // Probability of the ith item
>                 items[1, i] = r1[i, 2]
> 
>                 // Populates the ith column in the 2nd row (Instructor 2) with the 
>                 // Probability of the ith item
>                 items[2, i] = r2[i, 2]
> 
>                 // Populates the ith column in the 3rd row (Instructor 3) with the 
>                 // Probability of the ith item
>                 items[3, i] = r3[i, 2]
>                 
>                 // Gets the standard deviation of item probabilities across instructors
>                 sigmaitems[1, i] = sqrt(variance(items[., i]))
>                 
>         } // End of Loop
                 <istmt>:  3301  subscript invalid
(19 lines skipped)
------------------------------------------------------------------------------------------------------------------------------------
r(3301);

end of do-file

r(3301);

. clear

. cls

. discard

. do "/var/folders/px/cg4_66j52pvfn2z7pbjvb5d80000gn/T//SD01075.000000"

. // Stores division character from extended ascii range in a local macro
. loc div `: di _char(247)'

. 
. // Loads the data set containing the predicted pass/fail indicator, observed
. // scores, and item judgments
. import excel using ../data/raw.xlsx, clear first case(l)

. 
. // Recodes the predicted pass/fail indicator with a numeric value
. qui: replace porf = cond(porf == "P", "1", cond(porf == "F", "0", ""))

. 
. // Renames the variables from the original source
. rename (inst1 studno studscor porf itemno itemjud)(inst1 stdid score pred        ///   
> itemid itemdiff)

. 
. // Recasts the predicted pass/fail indicator as a numeric type
. qui: destring pred, replace

. 
. // Defines a pass/fail value label (masking) that attributes the labels with the
. // numeric values
. la def passfail 0 "Fail" 1 "Pass", modify

. 
. // Applies the passfail label to the values in the pred variable/column
. la val pred passfail

. 
. // Creates a numeric teacher ID (needed because Mata does not include objects 
. // that store text and numeric data in a single data frame like object
. qui: g byte tchid = cond(inst1 == "A", 1, cond(inst1 == "B", 2, 3))

. 
. // Starts the Mata interpreter
. mata:
------------------------------------------------- mata (type end to exit) ----------------------------------------------------------
: 
:         // Creates the object named angoff by selecting all of the non-missing values
:         // across the last three columns/variables in the data set (e.g., the item 
:         // judgments from the three instructors)
:         angoff = select(st_data(., (4..6)), rowmissing(st_data(., (4..6))) :== 0)

:         
:         // Defines a container object to store the individual instructor cutscores 
:         // and the cutscore defined by averaging over these ratings
:         cutscores = J(1, 4, .)

:         
:         // Loop over the values that identify individual instructors
:         for( i = 1; i <= 3; i++) {
>         
>                 // Replace the corresponding columns in the cutscores matrix with the 
>                 // sum of the item probabilities for each instructor
>                 cutscores[1, i] = colsum(select(angoff[., 2], angoff[., 3] :== i))
>                 
>         } // End of Loop

:         
:         // Averages the sum of the item probabilities across the instructors
:         cutscores[1, 4] = rowsum(cutscores[1, 1..3]) / 3

:         
:         // Creates a Stata matrix named cutscores that contains these values
:         st_matrix("cutscores", cutscores)

:         
:         // Creates an object to store the ratings from rater # 1
:         r1 = select(angoff[., (1..2)], angoff[., 3] :== 1)

:         
:         // Creates an object to store the ratings from rater # 2
:         r2 = select(angoff[., (1..2)], angoff[., 3] :== 2)

:         
:         // Creates an object to store the ratings from rater # 3
:         r3 = select(angoff[., (1..2)], angoff[., 3] :== 3)

:         
:         // Average item probability for instructor # 1
:         mu1 = mean(r1[., 2])

:         
:         // Average item probability for instructor # 2
:         mu2 = mean(r2[., 2])

:         
:         // Average item probability for instructor # 3
:         mu3 = mean(r3[., 2])

:         
:         // Standard deviation of item probabilities for instructor # 1
:         sigma1 = sqrt(variance(r1[., 2]))

:         
:         // Standard deviation of item probabilities for instructor # 2
:         sigma2 = sqrt(variance(r2[., 2]))

:         
:         // Standard deviation of item probabilities for instructor # 3
:         sigma3 = sqrt(variance(r3[., 2]))

:         
:         // Creates a container matrix to store the probabilities across columns
:         items = J(3, 13, .)

:         
:         // Container to store the standard deviations of each item
:         sigmaitems = J(1, 13, .)

:         
:         // Loops over the item indexes 
:         for(i = 1; i <= 13; i++) {
>         
>                 // Populates the ith column in the 1st row (Instructor 1) with the 
>                 // Probability of the ith item
>                 items[1, i] = r1[i, 2]
> 
>                 // Populates the ith column in the 2nd row (Instructor 2) with the 
>                 // Probability of the ith item
>                 items[2, i] = r2[i, 2]
> 
>                 // Populates the ith column in the 3rd row (Instructor 3) with the 
>                 // Probability of the ith item
>                 items[3, i] = r3[i, 2]
>                 
>                 // Gets the standard deviation of item probabilities across instructors
>                 sigmaitems[1, i] = sqrt(variance(items[., i]))
>                 
>         } // End of Loop
                 <istmt>:  3301  subscript invalid
(19 lines skipped)
------------------------------------------------------------------------------------------------------------------------------------
r(3301);

end of do-file

r(3301);

. do "/var/folders/px/cg4_66j52pvfn2z7pbjvb5d80000gn/T//SD01075.000000"

. // Stores division character from extended ascii range in a local macro
. loc div `: di _char(247)'

. 
. // Loads the data set containing the predicted pass/fail indicator, observed
. // scores, and item judgments
. import excel using ../data/raw.xlsx, clear first case(l)

. 
. // Recodes the predicted pass/fail indicator with a numeric value
. qui: replace porf = cond(porf == "P", "1", cond(porf == "F", "0", ""))

. 
. // Renames the variables from the original source
. rename (inst1 studno studscor porf itemno itemjud)(inst1 stdid score pred        ///   
> itemid itemdiff)

. 
. // Recasts the predicted pass/fail indicator as a numeric type
. qui: destring pred, replace

. 
. // Defines a pass/fail value label (masking) that attributes the labels with the
. // numeric values
. la def passfail 0 "Fail" 1 "Pass", modify

. 
. // Applies the passfail label to the values in the pred variable/column
. la val pred passfail

. 
. // Creates a numeric teacher ID (needed because Mata does not include objects 
. // that store text and numeric data in a single data frame like object
. qui: g byte tchid = cond(inst1 == "A", 1, cond(inst1 == "B", 2, 3))

. 
. // Starts the Mata interpreter
. mata:
------------------------------------------------- mata (type end to exit) ----------------------------------------------------------
: 
:         // Creates the object named angoff by selecting all of the non-missing values
:         // across the last three columns/variables in the data set (e.g., the item 
:         // judgments from the three instructors)
:         angoff = select(st_data(., (4..6)), rowmissing(st_data(., (4..6))) :== 0)

:         
:         // Defines a container object to store the individual instructor cutscores 
:         // and the cutscore defined by averaging over these ratings
:         cutscores = J(1, 4, .)

:         
:         // Loop over the values that identify individual instructors
:         for( i = 1; i <= 3; i++) {
>         
>                 // Replace the corresponding columns in the cutscores matrix with the 
>                 // sum of the item probabilities for each instructor
>                 cutscores[1, i] = colsum(select(angoff[., 2], angoff[., 3] :== i))
>                 
>         } // End of Loop

:         
:         // Averages the sum of the item probabilities across the instructors
:         cutscores[1, 4] = rowsum(cutscores[1, 1..3]) / 3

:         
:         // Creates a Stata matrix named cutscores that contains these values
:         st_matrix("cutscores", cutscores)

:         
:         // Creates an object to store the ratings from rater # 1
:         r1 = select(angoff[., (1..2)], angoff[., 3] :== 1)

:         
:         // Creates an object to store the ratings from rater # 2
:         r2 = select(angoff[., (1..2)], angoff[., 3] :== 2)

:         
:         // Creates an object to store the ratings from rater # 3
:         r3 = select(angoff[., (1..2)], angoff[., 3] :== 3)

:         
:         // Average item probability for instructor # 1
:         mu1 = mean(r1[., 2])

:         
:         // Average item probability for instructor # 2
:         mu2 = mean(r2[., 2])

:         
:         // Average item probability for instructor # 3
:         mu3 = mean(r3[., 2])

:         
:         // Standard deviation of item probabilities for instructor # 1
:         sigma1 = sqrt(variance(r1[., 2]))

:         
:         // Standard deviation of item probabilities for instructor # 2
:         sigma2 = sqrt(variance(r2[., 2]))

:         
:         // Standard deviation of item probabilities for instructor # 3
:         sigma3 = sqrt(variance(r3[., 2]))

:         
:         // Creates a container matrix to store the probabilities across columns
:         items = J(3, 13, .)

:         
:         // Container to store the standard deviations of each item
:         sigmaitems = J(1, 13, .)

:         
:         // Loops over the item indexes 
:         for(i = 1; i <= 13; i++) {
>         
>                 // Populates the ith column in the 1st row (Instructor 1) with the 
>                 // Probability of the ith item
>                 items[1, i] = r1[i, 2]
> 
>                 // Populates the ith column in the 2nd row (Instructor 2) with the 
>                 // Probability of the ith item
>                 items[2, i] = r2[i, 2]
> 
>                 // Populates the ith column in the 3rd row (Instructor 3) with the 
>                 // Probability of the ith item
>                 items[3, i] = r3[i, 2]
>                                 
>         } // End of Loop
                 <istmt>:  3301  subscript invalid
(27 lines skipped)
------------------------------------------------------------------------------------------------------------------------------------
r(3301);

end of do-file

r(3301);

. mata
------------------------------------------------- mata (type end to exit) ----------------------------------------------------------
: r1

: r2

: clear
                 <istmt>:  3499  clear not found
r(3499);

: end
------------------------------------------------------------------------------------------------------------------------------------

. clear

. discard

. prog drop _all

. cls

. do "/var/folders/px/cg4_66j52pvfn2z7pbjvb5d80000gn/T//SD01075.000000"

. import excel using ../data/raw.xlsx, clear first case(l)

. 
. // Recodes the predicted pass/fail indicator with a numeric value
. qui: replace porf = cond(porf == "P", "1", cond(porf == "F", "0", ""))

. 
. // Renames the variables from the original source
. rename (inst1 studno studscor porf itemno itemjud)(inst1 stdid score pred        ///   
> itemid itemdiff)

. 
. // Recasts the predicted pass/fail indicator as a numeric type
. qui: destring pred, replace

. 
. // Defines a pass/fail value label (masking) that attributes the labels with the
. // numeric values
. la def passfail 0 "Fail" 1 "Pass", modify

. 
. // Applies the passfail label to the values in the pred variable/column
. la val pred passfail

. 
. // Creates a numeric teacher ID (needed because Mata does not include objects 
. // that store text and numeric data in a single data frame like object
. qui: g byte tchid = cond(inst1 == "A", 1, cond(inst1 == "B", 2, 3))

. 
end of do-file

. mata
------------------------------------------------- mata (type end to exit) ----------------------------------------------------------
: angoff = select(st_data(., (4..6)), rowmissing(st_data(., (4..6))) :== 0)

: cutscores = J(1, 4, .)

: for( i = 1; i <= 3; i++) {
> cutscores[1, i] = colsum(select(angoff[., 2], angoff[., 3] :== i))
> }

: cutscores[1, 4] = rowsum(cutscores[1, 1..3]) / 3

: st_matrix("cutscores", cutscores)

: r1 = select(angoff[., (1..2)], angoff[., 3] :== 1)

: r2 = select(angoff[., (1..2)], angoff[., 3] :== 2)

: r3 = select(angoff[., (1..2)], angoff[., 3] :== 3)

: mu1 = mean(r1[., 2])

: mu2 = mean(r2[., 2])

: mu3 = mean(r3[., 2])

: sigma1 = sqrt(variance(r1[., 2]))

: sigma2 = sqrt(variance(r2[., 2]))

: sigma3 = sqrt(variance(r3[., 2]))

: items = J(3, 13, .)

: sigmaitems = J(1, 13, .)

: for(i = 1; i <= 13; i++) {
> items[1, i] = r1[i, 2]
> items[2, i] = r2[i, 2]
> items[3, i] = r3[i, 2]
> }
                 <istmt>:  3301  subscript invalid
r(3301);

: muitems = mean(items)

: for(i = 1; i <= 13; i++) {
> sigmaitems[1, i] = sqrt(variance(items[., i]))
> }

: itemsummary = (muitems', sigmaitems')

: ratersummary = (mu1, sigma1 \ mu2, sigma2 \ mu3, sigma3)

: st_matrix("items", itemsummary)

: st_matrix("raters", ratersummary)

: r1

: angoff
          1     2     3
     +-------------------+
   1 |    1     1    .7  |
   2 |    1     2   .45  |
   3 |    0     3    .6  |
   4 |    0     4    .4  |
   5 |    0     5    .4  |
   6 |    0     6   .35  |
   7 |    1     7   .35  |
   8 |    1     8   .35  |
   9 |    0     9    .3  |
  10 |    0    10    .3  |
  11 |    0    11    .3  |
  12 |    0    12   .25  |
  13 |    1     1    .8  |
  14 |    0     2    .5  |
  15 |    1     3    .5  |
  16 |    1     4    .3  |
  17 |    1     5    .4  |
  18 |    1     6    .8  |
  19 |    1     7    .6  |
  20 |    0     8    .3  |
  21 |    1     9    .5  |
  22 |    0    10    .3  |
  23 |    1    11    .5  |
  24 |    0    12    .6  |
  25 |    1    13    .3  |
  26 |    1     1    .9  |
  27 |    1     2    .8  |
  28 |    1     3    .7  |
  29 |    1     4    .7  |
  30 |    1     5    .8  |
  31 |    1     6    .8  |
  32 |    0     7    .7  |
  33 |    1     8    .7  |
     +-------------------+

: angoff = select(st_data(., (5..7)), rowmissing(st_data(., (5..7))) :== 0)

: angoff
          1     2     3
     +-------------------+
   1 |    1    .7     1  |
   2 |    2   .45     1  |
   3 |    3    .6     1  |
   4 |    4    .4     1  |
   5 |    5    .4     1  |
   6 |    6   .35     1  |
   7 |    7   .35     1  |
   8 |    8   .35     1  |
   9 |    9    .3     1  |
  10 |   10    .3     1  |
  11 |   11    .3     1  |
  12 |   12   .25     1  |
  13 |   13   .25     1  |
  14 |    1    .8     2  |
  15 |    2    .5     2  |
  16 |    3    .5     2  |
  17 |    4    .3     2  |
  18 |    5    .4     2  |
  19 |    6    .8     2  |
  20 |    7    .6     2  |
  21 |    8    .3     2  |
  22 |    9    .5     2  |
  23 |   10    .3     2  |
  24 |   11    .5     2  |
  25 |   12    .6     2  |
  26 |   13    .3     2  |
  27 |    1    .9     3  |
  28 |    2    .8     3  |
  29 |    3    .7     3  |
  30 |    4    .7     3  |
  31 |    5    .8     3  |
  32 |    6    .8     3  |
  33 |    7    .7     3  |
  34 |    8    .7     3  |
  35 |    9    .7     3  |
  36 |   10    .7     3  |
  37 |   11    .7     3  |
  38 |   12    .6     3  |
  39 |   13    .8     3  |
     +-------------------+

: for( i = 1; i <= 3; i++) {
> cutscores[1, i] = colsum(select(angoff[., 2], angoff[., 3] :== i))
> }

: cutscores[1, 4] = rowsum(cutscores[1, 1..3]) / 3

: st_matrix("cutscores", cutscores)

: r1 = select(angoff[., (1..2)], angoff[., 3] :== 1)

: r2 = select(angoff[., (1..2)], angoff[., 3] :== 2)

: r3 = select(angoff[., (1..2)], angoff[., 3] :== 3)

: mu1 = mean(r1[., 2])

: mu2 = mean(r2[., 2])

: mu3 = mean(r3[., 2])

: sigma1 = sqrt(variance(r1[., 2]))

: sigma2 = sqrt(variance(r2[., 2]))

: sigma3 = sqrt(variance(r3[., 2]))

: items = J(3, 13, .)

: sigmaitems = J(1, 13, .)

: for(i = 1; i <= 13; i++) {
> items[1, i] = r1[i, 2]
> items[2, i] = r2[i, 2]
> items[3, i] = r3[i, 2]
> }

: muitems = mean(items)

: for(i = 1; i <= 13; i++) {
> sigmaitems[1, i] = sqrt(variance(items[., i]))
> }

: itemsummary = (muitems', sigmaitems')

: ratersummary = (mu1, sigma1 \ mu2, sigma2 \ mu3, sigma3)

: st_matrix("items", itemsummary)

: st_matrix("raters", ratersummary)

: items
         1     2     3     4     5     6     7     8     9    10    11    12    13
    +-------------------------------------------------------------------------------+
  1 |   .7   .45    .6    .4    .4   .35   .35   .35    .3    .3    .3   .25   .25  |
  2 |   .8    .5    .5    .3    .4    .8    .6    .3    .5    .3    .5    .6    .3  |
  3 |   .9    .8    .7    .7    .8    .8    .7    .7    .7    .7    .7    .6    .8  |
    +-------------------------------------------------------------------------------+

: raters
                 <istmt>:  3499  raters not found
r(3499);

: ratersummary
                 1             2
    +-----------------------------+
  1 |  .3846153846   .1328918975  |
  2 |  .4923076923   .1754116039  |
  3 |  .7384615385   .0767947648  |
    +-----------------------------+

: end
------------------------------------------------------------------------------------------------------------------------------------

. clear

. discard

. cls

. do "/var/folders/px/cg4_66j52pvfn2z7pbjvb5d80000gn/T//SD01075.000000"

. loc div `: di _char(247)'

. 
. // Loads the data set containing the predicted pass/fail indicator, observed
. // scores, and item judgments
. import excel using ../data/raw.xlsx, clear first case(l)

. 
. // Recodes the predicted pass/fail indicator with a numeric value
. qui: replace porf = cond(porf == "P", "1", cond(porf == "F", "0", ""))

. 
. // Renames the variables from the original source
. rename (inst1 studno studscor porf itemno itemjud)(inst1 stdid score pred        ///   
> itemid itemdiff)

. 
. // Recasts the predicted pass/fail indicator as a numeric type
. qui: destring pred, replace

. 
. // Defines a pass/fail value label (masking) that attributes the labels with the
. // numeric values
. la def passfail 0 "Fail" 1 "Pass", modify

. 
. // Applies the passfail label to the values in the pred variable/column
. la val pred passfail

. 
. // Creates a numeric teacher ID (needed because Mata does not include objects 
. // that store text and numeric data in a single data frame like object
. qui: g byte tchid = cond(inst1 == "A", 1, cond(inst1 == "B", 2, 3))

. 
. // Starts the Mata interpreter
. mata:
------------------------------------------------- mata (type end to exit) ----------------------------------------------------------
: 
:         // Creates the object named angoff by selecting all of the non-missing values
:         // across the last three columns/variables in the data set (e.g., the item 
:         // judgments from the three instructors)
:         angoff = select(st_data(., (5..7)), rowmissing(st_data(., (5..7))) :== 0)

:         
:         // Defines a container object to store the individual instructor cutscores 
:         // and the cutscore defined by averaging over these ratings
:         cutscores = J(1, 4, .)

:         
:         // Loop over the values that identify individual instructors
:         for( i = 1; i <= 3; i++) {
>         
>                 // Replace the corresponding columns in the cutscores matrix with the 
>                 // sum of the item probabilities for each instructor
>                 cutscores[1, i] = colsum(select(angoff[., 2], angoff[., 3] :== i))
>                 
>         } // End of Loop

:         
:         // Averages the sum of the item probabilities across the instructors
:         cutscores[1, 4] = rowsum(cutscores[1, 1..3]) / 3

:         
:         // Creates a Stata matrix named cutscores that contains these values
:         st_matrix("cutscores", cutscores)

:         
:         // Creates an object to store the ratings from rater # 1
:         r1 = select(angoff[., (1..2)], angoff[., 3] :== 1)

:         
:         // Creates an object to store the ratings from rater # 2
:         r2 = select(angoff[., (1..2)], angoff[., 3] :== 2)

:         
:         // Creates an object to store the ratings from rater # 3
:         r3 = select(angoff[., (1..2)], angoff[., 3] :== 3)

:         
:         // Average item probability for instructor # 1
:         mu1 = mean(r1[., 2])

:         
:         // Average item probability for instructor # 2
:         mu2 = mean(r2[., 2])

:         
:         // Average item probability for instructor # 3
:         mu3 = mean(r3[., 2])

:         
:         // Standard deviation of item probabilities for instructor # 1
:         sigma1 = sqrt(variance(r1[., 2]))

:         
:         // Standard deviation of item probabilities for instructor # 2
:         sigma2 = sqrt(variance(r2[., 2]))

:         
:         // Standard deviation of item probabilities for instructor # 3
:         sigma3 = sqrt(variance(r3[., 2]))

:         
:         // Creates a container matrix to store the probabilities across columns
:         items = J(3, 13, .)

:         
:         // Container to store the standard deviations of each item
:         sigmaitems = J(1, 13, .)

:         
:         // Loops over the item indexes 
:         for(i = 1; i <= 13; i++) {
>         
>                 // Populates the ith column in the 1st row (Instructor 1) with the 
>                 // Probability of the ith item
>                 items[1, i] = r1[i, 2]
> 
>                 // Populates the ith column in the 2nd row (Instructor 2) with the 
>                 // Probability of the ith item
>                 items[2, i] = r2[i, 2]
> 
>                 // Populates the ith column in the 3rd row (Instructor 3) with the 
>                 // Probability of the ith item
>                 items[3, i] = r3[i, 2]
>                                 
>         } // End of Loop

:         
:         // Gets the item averages across instructors 
:         muitems = mean(items)

: 
:         // Loop over items again
:         for(i = 1; i <= 13; i++) {
>         
>                 // Gets the standard deviation of item probabilities across instructors
>                 sigmaitems[1, i] = sqrt(variance(items[., i]))
> 
>         } // End Loop to get the standard deviations across items       

:         
:         // Creates the item summary matrix by appending the transpose of the average
:         // and standard deviations (e.g., from row to column vectors)
:         itemsummary = (muitems', sigmaitems')

:         
:         // Builds the rater summary matrix with average and standard deviation of 
:         // each rater in the same row
:         ratersummary = (mu1, sigma1 \ mu2, sigma2 \ mu3, sigma3)

: 
:         // Creates a Stata matrix named items to store the item summary matrix
:         st_matrix("items", itemsummary)

:         
:         // Creates a Stata matrix named raters to store the rater summary matrix
:         st_matrix("raters", ratersummary)

:         
: // End Mata interpreter 
: end
------------------------------------------------------------------------------------------------------------------------------------

. 
. // Item stem for item # 1
. loc istem1 "Simplify 9/15"

. 
. // Item stem for item # 2
. loc istem2 "Multiply and Simplify 2/5 * 35"

. 
. // Item stem for item # 3
. loc istem3 "Multiply and Simplify 3/10 * 43/100"

. 
. // Item stem for item # 4
. loc istem4 "Divide and Simplify 7/2 `div' 49/4"

. 
. // Item stem for item # 5
. loc istem5 "Divide and Simplify 7/4 `div' 7"

. 
. // Item stem for item # 6
. loc istem6 "Add and Simplify 7/8 + 7/8"

. 
. // Item stem for item # 7
. loc istem7 "Add and Simplify 7/9 + 5/6"

. 
. // Item stem for item # 8
. loc istem8 "Subtract and Simplify 7/10 - 13/25"

. 
. // Item stem for item # 9
. loc istem9 "Add (write the answer as a mixed numeral) 6 5/6 + 2 5/6"

. 
. // Item stem for item # 10
. loc istem10 "Add 8 1/9 + 7 2/5"

. 
. // Item stem for item # 11
. loc istem11 "Subtract 9 2/5 - 5 1/3"

. 
. // Item stem for item # 12
. loc istem12 "Subtract (write a mixed numeral for the answer) 27 - 22 1/2"

. 
. // Item stem for item # 13
. loc istem13 "Divide (write as mixed numeral) 12 `div' 1 1/13"

. 
. // Loops over item indices
. forv i = 1/13 {
  2. 
.         // Contructs a macro containing the item stem and item ID 
.         loc irownames `"`irownames' "Item `i' : `istem`i''""'
  3.         //loc irownames `irownames' Item`i'
. 
. } // End of loop over item indices

. 
. // Column names for the item/rater summary matrices
. loc colnms Mean "Std Dev"

. 
. // Row names for the item summary matrix
. mat rownames items = `irownames'
Subtract and Simplify 7/10 - 13/25 invalid name
r(198);

end of do-file

r(198);

. ascii
33  ! 34  " 35  # 36  $ 37  % 38  & 39  ' 40  ( 41  ) 42  * 43  + 44  , 45  - 46  . 47  / 48  0 49  1 50  2 51  3 52  4 53  5 54  6
55  7 56  8 57  9 58  : 59  ; 60  < 61  = 62  > 63  ? 64  @ 65  A 66  B 67  C 68  D 69  E 70  F 71  G 72  H 73  I 74  J 75  K 76  L
77  M 78  N 79  O 80  P 81  Q 82  R 83  S 84  T 85  U 86  V 87  W 88  X 89  Y 90  Z 91  [ 92  \ 93  ] 94  ^ 95  _ 96  ` 97  a 98  b
99  c 100 d 101 e 102 f 103 g 104 h 105 i 106 j 107 k 108 l 109 m 110 n 111 o 112 p 113 q 114 r 115 s 116 t 117 u 118 v 119 w 120 x
121 y 122 z 123 { 124 | 125 } 126 ~ 127  128 ‚Ç¨ 129 ¬Å 130 ‚Äö 131 ∆í 132 ‚Äû 133 ‚Ä¶ 134 ‚Ä† 135 ‚Ä° 136 ÀÜ 137 ‚Ä∞ 138 ≈† 139 ‚Äπ 140 ≈í 141 ¬ç 142 ≈Ω
143 ¬è 144 ¬ê 145 ‚Äò 146 ‚Äô 147 ‚Äú 148 ‚Äù 149 ‚Ä¢ 150 ‚Äì 151 ‚Äî 152 Àú 153 ‚Ñ¢ 154 ≈° 155 ‚Ä∫ 156 ≈ì 157 ¬ù 158 ≈æ 159 ≈∏ 160 ¬† 161 ¬° 162 ¬¢ 163 ¬£ 164 ¬§
165 ¬• 166 ¬¶ 167 ¬ß 168 ¬® 169 ¬© 170 ¬™ 171 ¬´ 172 ¬¨ 173 ¬≠ 174 ¬Æ 175 ¬Ø 176 ¬∞ 177 ¬± 178 ¬≤ 179 ¬≥ 180 ¬¥ 181 ¬µ 182 ¬∂ 183 ¬∑ 184 ¬∏ 185 ¬π 186 ¬∫
187 ¬ª 188 ¬º 189 ¬Ω 190 ¬æ 191 ¬ø 192 √Ä 193 √Å 194 √Ç 195 √É 196 √Ñ 197 √Ö 198 √Ü 199 √á 200 √à 201 √â 202 √ä 203 √ã 204 √å 205 √ç 206 √é 207 √è 208 √ê
209 √ë 210 √í 211 √ì 212 √î 213 √ï 214 √ñ 215 √ó 216 √ò 217 √ô 218 √ö 219 √õ 220 √ú 221 √ù 222 √û 223 √ü 224 √† 225 √° 226 √¢ 227 √£ 228 √§ 229 √• 230 √¶
231 √ß 232 √® 233 √© 234 √™ 235 √´ 236 √¨ 237 √≠ 238 √Æ 239 √Ø 240 √∞ 241 √± 242 √≤ 243 √≥ 244 √¥ 245 √µ 246 √∂ 247 √∑ 248 √∏ 249 √π 250 √∫ 251 √ª 252 √º
253 √Ω 254 √æ 255 √ø
. di _char(45)
-

. di _char(47)
/

. di _char(43)
+

. do "/var/folders/px/cg4_66j52pvfn2z7pbjvb5d80000gn/T//SD01075.000000"

. // Stores division character from extended ascii range in a local macro
. loc divdot `: di _char(247)'

. 
. // Store multiplication dot
. loc multiply `: di _char(149)'

. 
. // Store addition operator
. loc add `: di _char(43)'

. 
. // Store difference operator
. loc sub `: di _char(45)'

. 
. // Store fraction/division operator
. loc div `: di _char(47)'

. 
. // Loads the data set containing the predicted pass/fail indicator, observed
. // scores, and item judgments
. import excel using ../data/raw.xlsx, clear first case(l)

. 
. // Recodes the predicted pass/fail indicator with a numeric value
. qui: replace porf = cond(porf == "P", "1", cond(porf == "F", "0", ""))

. 
. // Renames the variables from the original source
. rename (inst1 studno studscor porf itemno itemjud)(inst1 stdid score pred        ///   
> itemid itemdiff)

. 
. // Recasts the predicted pass/fail indicator as a numeric type
. qui: destring pred, replace

. 
. // Defines a pass/fail value label (masking) that attributes the labels with the
. // numeric values
. la def passfail 0 "Fail" 1 "Pass", modify

. 
. // Applies the passfail label to the values in the pred variable/column
. la val pred passfail

. 
. // Creates a numeric teacher ID (needed because Mata does not include objects 
. // that store text and numeric data in a single data frame like object
. qui: g byte tchid = cond(inst1 == "A", 1, cond(inst1 == "B", 2, 3))

. 
. // Starts the Mata interpreter
. mata:
------------------------------------------------- mata (type end to exit) ----------------------------------------------------------
: 
:         // Creates the object named angoff by selecting all of the non-missing values
:         // across the last three columns/variables in the data set (e.g., the item 
:         // judgments from the three instructors)
:         angoff = select(st_data(., (5..7)), rowmissing(st_data(., (5..7))) :== 0)

:         
:         // Defines a container object to store the individual instructor cutscores 
:         // and the cutscore defined by averaging over these ratings
:         cutscores = J(1, 4, .)

:         
:         // Loop over the values that identify individual instructors
:         for( i = 1; i <= 3; i++) {
>         
>                 // Replace the corresponding columns in the cutscores matrix with the 
>                 // sum of the item probabilities for each instructor
>                 cutscores[1, i] = colsum(select(angoff[., 2], angoff[., 3] :== i))
>                 
>         } // End of Loop

:         
:         // Averages the sum of the item probabilities across the instructors
:         cutscores[1, 4] = rowsum(cutscores[1, 1..3]) / 3

:         
:         // Creates a Stata matrix named cutscores that contains these values
:         st_matrix("cutscores", cutscores)

:         
:         // Creates an object to store the ratings from rater # 1
:         r1 = select(angoff[., (1..2)], angoff[., 3] :== 1)

:         
:         // Creates an object to store the ratings from rater # 2
:         r2 = select(angoff[., (1..2)], angoff[., 3] :== 2)

:         
:         // Creates an object to store the ratings from rater # 3
:         r3 = select(angoff[., (1..2)], angoff[., 3] :== 3)

:         
:         // Average item probability for instructor # 1
:         mu1 = mean(r1[., 2])

:         
:         // Average item probability for instructor # 2
:         mu2 = mean(r2[., 2])

:         
:         // Average item probability for instructor # 3
:         mu3 = mean(r3[., 2])

:         
:         // Standard deviation of item probabilities for instructor # 1
:         sigma1 = sqrt(variance(r1[., 2]))

:         
:         // Standard deviation of item probabilities for instructor # 2
:         sigma2 = sqrt(variance(r2[., 2]))

:         
:         // Standard deviation of item probabilities for instructor # 3
:         sigma3 = sqrt(variance(r3[., 2]))

:         
:         // Creates a container matrix to store the probabilities across columns
:         items = J(3, 13, .)

:         
:         // Container to store the standard deviations of each item
:         sigmaitems = J(1, 13, .)

:         
:         // Loops over the item indexes 
:         for(i = 1; i <= 13; i++) {
>         
>                 // Populates the ith column in the 1st row (Instructor 1) with the 
>                 // Probability of the ith item
>                 items[1, i] = r1[i, 2]
> 
>                 // Populates the ith column in the 2nd row (Instructor 2) with the 
>                 // Probability of the ith item
>                 items[2, i] = r2[i, 2]
> 
>                 // Populates the ith column in the 3rd row (Instructor 3) with the 
>                 // Probability of the ith item
>                 items[3, i] = r3[i, 2]
>                                 
>         } // End of Loop

:         
:         // Gets the item averages across instructors 
:         muitems = mean(items)

: 
:         // Loop over items again
:         for(i = 1; i <= 13; i++) {
>         
>                 // Gets the standard deviation of item probabilities across instructors
>                 sigmaitems[1, i] = sqrt(variance(items[., i]))
> 
>         } // End Loop to get the standard deviations across items       

:         
:         // Creates the item summary matrix by appending the transpose of the average
:         // and standard deviations (e.g., from row to column vectors)
:         itemsummary = (muitems', sigmaitems')

:         
:         // Builds the rater summary matrix with average and standard deviation of 
:         // each rater in the same row
:         ratersummary = (mu1, sigma1 \ mu2, sigma2 \ mu3, sigma3)

: 
:         // Creates a Stata matrix named items to store the item summary matrix
:         st_matrix("items", itemsummary)

:         
:         // Creates a Stata matrix named raters to store the rater summary matrix
:         st_matrix("raters", ratersummary)

:         
: // End Mata interpreter 
: end
------------------------------------------------------------------------------------------------------------------------------------

. 
. // Item stem for item # 1
. loc istem1 "Simplify 9`div'15"

. 
. // Item stem for item # 2
. loc istem2 "Multiply and Simplify 2`div'5 `multiply' 35"

. 
. // Item stem for item # 3
. loc istem3 "Multiply and Simplify 3`div'10 `multiply' 43`div'100"

. 
. // Item stem for item # 4
. loc istem4 "Divide and Simplify 7`div'2 `divdot' 49`div'4"

. 
. // Item stem for item # 5
. loc istem5 "Divide and Simplify 7`div'4 `divdot' 7"

. 
. // Item stem for item # 6
. loc istem6 "Add and Simplify 7`div'8 `add' 7`div'8"

. 
. // Item stem for item # 7
. loc istem7 "Add and Simplify 7`div'9 `add' 5`div'6"

. 
. // Item stem for item # 8
. loc istem8 "Subtract and Simplify 7`div'10 `sub' 13`div'25"

. 
. // Item stem for item # 9
. loc istem9 "Add (write the answer as a mixed numeral) 6 5`div'6 `add' 2 5`div'6"

. 
. // Item stem for item # 10
. loc istem10 "Add 8 1`div'9 `add' 7 2`div'5"

. 
. // Item stem for item # 11
. loc istem11 "Subtract 9 2`div'5 `sub' 5 1`div'3"

. 
. // Item stem for item # 12
. loc istem12 "Subtract (write a mixed numeral for the answer) 27 `sub' 22 1`div'2"

. 
. // Item stem for item # 13
. loc istem13 "Divide (write as mixed numeral) 12 `divdot' 1 1`div'13"

. 
. // Loops over item indices
. forv i = 1/13 {
  2. 
.         // Contructs a macro containing the item stem and item ID 
.         loc irownames `"`irownames' "Item `i' : `istem`i''""'
  3.         //loc irownames `irownames' Item`i'
. 
. } // End of loop over item indices

. 
. // Column names for the item/rater summary matrices
. loc colnms Mean "Std Dev"

. 
. // Row names for the item summary matrix
. mat rownames items = `irownames'
Multiply and Simplify 3/10 ¬ï 43/100 invalid name
r(198);

end of do-file

r(198);

. di _char(246)
√∂

. di _char(245)
√µ

. di _char(243)
√≥

. di _char(247)
√∑

. di _char(248)
√∏

. di _char(249)
√π

. di _char(250)
√∫

. di _char(251)
√ª

. di _char(252)
√º

. di _char(253)
√Ω

. di _char(254)
√æ

. di _char(255)
√ø

. forv i = 1/255 {
  2. di `"_char(`i') == "' _char(`i')
  3. }
_char(1) == 
_char(2) == 
_char(3) == 
_char(4) == 
_char(5) == 
_char(6) == 
_char(7) == 
_char(8) == 
_char(9) ==     
_char(10) == 

_char(11) == 
_char(12) == 
_char(13) == 
_char(14) == 
_char(15) == 
_char(16) == 
_char(17) == 
_char(18) == 
_char(19) == 
_char(20) == 
_char(21) == 
_char(22) == 
_char(23) == 
_char(24) == 
_char(25) == 
_char(26) == 
_char(27) == 
_char(28) == 
_char(29) == 
_char(30) == 
_char(31) == 
_char(32) ==  
_char(33) == !
_char(34) == "
_char(35) == #
_char(36) == $
_char(37) == %
_char(38) == &
_char(39) == '
_char(40) == (
_char(41) == )
_char(42) == *
_char(43) == +
_char(44) == ,
_char(45) == -
_char(46) == .
_char(47) == /
_char(48) == 0
_char(49) == 1
_char(50) == 2
_char(51) == 3
_char(52) == 4
_char(53) == 5
_char(54) == 6
_char(55) == 7
_char(56) == 8
_char(57) == 9
_char(58) == :
_char(59) == ;
_char(60) == <
_char(61) == =
_char(62) == >
_char(63) == ?
_char(64) == @
_char(65) == A
_char(66) == B
_char(67) == C
_char(68) == D
_char(69) == E
_char(70) == F
_char(71) == G
_char(72) == H
_char(73) == I
_char(74) == J
_char(75) == K
_char(76) == L
_char(77) == M
_char(78) == N
_char(79) == O
_char(80) == P
_char(81) == Q
_char(82) == R
_char(83) == S
_char(84) == T
_char(85) == U
_char(86) == V
_char(87) == W
_char(88) == X
_char(89) == Y
_char(90) == Z
_char(91) == [
_char(92) == \
_char(93) == ]
_char(94) == ^
_char(95) == _
_char(96) == `
_char(97) == a
_char(98) == b
_char(99) == c
_char(100) == d
_char(101) == e
_char(102) == f
_char(103) == g
_char(104) == h
_char(105) == i
_char(106) == j
_char(107) == k
_char(108) == l
_char(109) == m
_char(110) == n
_char(111) == o
_char(112) == p
_char(113) == q
_char(114) == r
_char(115) == s
_char(116) == t
_char(117) == u
_char(118) == v
_char(119) == w
_char(120) == x
_char(121) == y
_char(122) == z
_char(123) == {
_char(124) == |
_char(125) == }
_char(126) == ~
_char(127) == 
_char(128) == ¬Ä
_char(129) == ¬Å
_char(130) == ¬Ç
_char(131) == ¬É
_char(132) == ¬Ñ
_char(133) == ¬Ö
_char(134) == ¬Ü
_char(135) == ¬á
_char(136) == ¬à
_char(137) == ¬â
_char(138) == ¬ä
_char(139) == ¬ã
_char(140) == ¬å
_char(141) == ¬ç
_char(142) == ¬é
_char(143) == ¬è
_char(144) == ¬ê
_char(145) == ¬ë
_char(146) == ¬í
_char(147) == ¬ì
_char(148) == ¬î
_char(149) == ¬ï
_char(150) == ¬ñ
_char(151) == ¬ó
_char(152) == ¬ò
_char(153) == ¬ô
_char(154) == ¬ö
_char(155) == ¬õ
_char(156) == ¬ú
_char(157) == ¬ù
_char(158) == ¬û
_char(159) == ¬ü
_char(160) == ¬†
_char(161) == ¬°
_char(162) == ¬¢
_char(163) == ¬£
_char(164) == ¬§
_char(165) == ¬•
_char(166) == ¬¶
_char(167) == ¬ß
_char(168) == ¬®
_char(169) == ¬©
_char(170) == ¬™
_char(171) == ¬´
_char(172) == ¬¨
_char(173) == ¬≠
_char(174) == ¬Æ
_char(175) == ¬Ø
_char(176) == ¬∞
_char(177) == ¬±
_char(178) == ¬≤
_char(179) == ¬≥
_char(180) == ¬¥
_char(181) == ¬µ
_char(182) == ¬∂
_char(183) == ¬∑
_char(184) == ¬∏
_char(185) == ¬π
_char(186) == ¬∫
_char(187) == ¬ª
_char(188) == ¬º
_char(189) == ¬Ω
_char(190) == ¬æ
_char(191) == ¬ø
_char(192) == √Ä
_char(193) == √Å
_char(194) == √Ç
_char(195) == √É
_char(196) == √Ñ
_char(197) == √Ö
_char(198) == √Ü
_char(199) == √á
_char(200) == √à
_char(201) == √â
_char(202) == √ä
_char(203) == √ã
_char(204) == √å
_char(205) == √ç
_char(206) == √é
_char(207) == √è
_char(208) == √ê
_char(209) == √ë
_char(210) == √í
_char(211) == √ì
_char(212) == √î
_char(213) == √ï
_char(214) == √ñ
_char(215) == √ó
_char(216) == √ò
_char(217) == √ô
_char(218) == √ö
_char(219) == √õ
_char(220) == √ú
_char(221) == √ù
_char(222) == √û
_char(223) == √ü
_char(224) == √†
_char(225) == √°
_char(226) == √¢
_char(227) == √£
_char(228) == √§
_char(229) == √•
_char(230) == √¶
_char(231) == √ß
_char(232) == √®
_char(233) == √©
_char(234) == √™
_char(235) == √´
_char(236) == √¨
_char(237) == √≠
_char(238) == √Æ
_char(239) == √Ø
_char(240) == √∞
_char(241) == √±
_char(242) == √≤
_char(243) == √≥
_char(244) == √¥
_char(245) == √µ
_char(246) == √∂
_char(247) == √∑
_char(248) == √∏
_char(249) == √π
_char(250) == √∫
_char(251) == √ª
_char(252) == √º
_char(253) == √Ω
_char(254) == √æ
_char(255) == √ø

. do "/var/folders/px/cg4_66j52pvfn2z7pbjvb5d80000gn/T//SD01075.000000"

. loc divdot `: di _char(247)'

. 
. // Store multiplication dot
. loc multiply `: di _char(42)'

. 
. // Store addition operator
. loc add `: di _char(43)'

. 
. // Store difference operator
. loc sub `: di _char(45)'

. 
. // Store fraction/division operator
. loc div `: di _char(47)'

. 
. // Loads the data set containing the predicted pass/fail indicator, observed
. // scores, and item judgments
. import excel using ../data/raw.xlsx, clear first case(l)

. 
. // Recodes the predicted pass/fail indicator with a numeric value
. qui: replace porf = cond(porf == "P", "1", cond(porf == "F", "0", ""))

. 
. // Renames the variables from the original source
. rename (inst1 studno studscor porf itemno itemjud)(inst1 stdid score pred        ///   
> itemid itemdiff)

. 
. // Recasts the predicted pass/fail indicator as a numeric type
. qui: destring pred, replace

. 
. // Defines a pass/fail value label (masking) that attributes the labels with the
. // numeric values
. la def passfail 0 "Fail" 1 "Pass", modify

. 
. // Applies the passfail label to the values in the pred variable/column
. la val pred passfail

. 
. // Creates a numeric teacher ID (needed because Mata does not include objects 
. // that store text and numeric data in a single data frame like object
. qui: g byte tchid = cond(inst1 == "A", 1, cond(inst1 == "B", 2, 3))

. 
. // Starts the Mata interpreter
. mata:
------------------------------------------------- mata (type end to exit) ----------------------------------------------------------
: 
:         // Creates the object named angoff by selecting all of the non-missing values
:         // across the last three columns/variables in the data set (e.g., the item 
:         // judgments from the three instructors)
:         angoff = select(st_data(., (5..7)), rowmissing(st_data(., (5..7))) :== 0)

:         
:         // Defines a container object to store the individual instructor cutscores 
:         // and the cutscore defined by averaging over these ratings
:         cutscores = J(1, 4, .)

:         
:         // Loop over the values that identify individual instructors
:         for( i = 1; i <= 3; i++) {
>         
>                 // Replace the corresponding columns in the cutscores matrix with the 
>                 // sum of the item probabilities for each instructor
>                 cutscores[1, i] = colsum(select(angoff[., 2], angoff[., 3] :== i))
>                 
>         } // End of Loop

:         
:         // Averages the sum of the item probabilities across the instructors
:         cutscores[1, 4] = rowsum(cutscores[1, 1..3]) / 3

:         
:         // Creates a Stata matrix named cutscores that contains these values
:         st_matrix("cutscores", cutscores)

:         
:         // Creates an object to store the ratings from rater # 1
:         r1 = select(angoff[., (1..2)], angoff[., 3] :== 1)

:         
:         // Creates an object to store the ratings from rater # 2
:         r2 = select(angoff[., (1..2)], angoff[., 3] :== 2)

:         
:         // Creates an object to store the ratings from rater # 3
:         r3 = select(angoff[., (1..2)], angoff[., 3] :== 3)

:         
:         // Average item probability for instructor # 1
:         mu1 = mean(r1[., 2])

:         
:         // Average item probability for instructor # 2
:         mu2 = mean(r2[., 2])

:         
:         // Average item probability for instructor # 3
:         mu3 = mean(r3[., 2])

:         
:         // Standard deviation of item probabilities for instructor # 1
:         sigma1 = sqrt(variance(r1[., 2]))

:         
:         // Standard deviation of item probabilities for instructor # 2
:         sigma2 = sqrt(variance(r2[., 2]))

:         
:         // Standard deviation of item probabilities for instructor # 3
:         sigma3 = sqrt(variance(r3[., 2]))

:         
:         // Creates a container matrix to store the probabilities across columns
:         items = J(3, 13, .)

:         
:         // Container to store the standard deviations of each item
:         sigmaitems = J(1, 13, .)

:         
:         // Loops over the item indexes 
:         for(i = 1; i <= 13; i++) {
>         
>                 // Populates the ith column in the 1st row (Instructor 1) with the 
>                 // Probability of the ith item
>                 items[1, i] = r1[i, 2]
> 
>                 // Populates the ith column in the 2nd row (Instructor 2) with the 
>                 // Probability of the ith item
>                 items[2, i] = r2[i, 2]
> 
>                 // Populates the ith column in the 3rd row (Instructor 3) with the 
>                 // Probability of the ith item
>                 items[3, i] = r3[i, 2]
>                                 
>         } // End of Loop

:         
:         // Gets the item averages across instructors 
:         muitems = mean(items)

: 
:         // Loop over items again
:         for(i = 1; i <= 13; i++) {
>         
>                 // Gets the standard deviation of item probabilities across instructors
>                 sigmaitems[1, i] = sqrt(variance(items[., i]))
> 
>         } // End Loop to get the standard deviations across items       

:         
:         // Creates the item summary matrix by appending the transpose of the average
:         // and standard deviations (e.g., from row to column vectors)
:         itemsummary = (muitems', sigmaitems')

:         
:         // Builds the rater summary matrix with average and standard deviation of 
:         // each rater in the same row
:         ratersummary = (mu1, sigma1 \ mu2, sigma2 \ mu3, sigma3)

: 
:         // Creates a Stata matrix named items to store the item summary matrix
:         st_matrix("items", itemsummary)

:         
:         // Creates a Stata matrix named raters to store the rater summary matrix
:         st_matrix("raters", ratersummary)

:         
: // End Mata interpreter 
: end
------------------------------------------------------------------------------------------------------------------------------------

. 
. // Item stem for item # 1
. loc istem1 "Simplify 9`div'15"

. 
. // Item stem for item # 2
. loc istem2 "Multiply and Simplify 2`div'5 `multiply' 35"

. 
. // Item stem for item # 3
. loc istem3 "Multiply and Simplify 3`div'10 `multiply' 43`div'100"

. 
. // Item stem for item # 4
. loc istem4 "Divide and Simplify 7`div'2 `divdot' 49`div'4"

. 
. // Item stem for item # 5
. loc istem5 "Divide and Simplify 7`div'4 `divdot' 7"

. 
. // Item stem for item # 6
. loc istem6 "Add and Simplify 7`div'8 `add' 7`div'8"

. 
. // Item stem for item # 7
. loc istem7 "Add and Simplify 7`div'9 `add' 5`div'6"

. 
. // Item stem for item # 8
. loc istem8 "Subtract and Simplify 7`div'10 `sub' 13`div'25"

. 
. // Item stem for item # 9
. loc istem9 "Add (write the answer as a mixed numeral) 6 5`div'6 `add' 2 5`div'6"

. 
. // Item stem for item # 10
. loc istem10 "Add 8 1`div'9 `add' 7 2`div'5"

. 
. // Item stem for item # 11
. loc istem11 "Subtract 9 2`div'5 `sub' 5 1`div'3"

. 
. // Item stem for item # 12
. loc istem12 "Subtract (write a mixed numeral for the answer) 27 `sub' 22 1`div'2"

. 
. // Item stem for item # 13
. loc istem13 "Divide (write as mixed numeral) 12 `divdot' 1 1`div'13"

. 
. // Loops over item indices
. forv i = 1/13 {
  2. 
.         // Contructs a macro containing the item stem and item ID 
.         loc irownames `"`irownames' "Item `i' : `istem`i''""'
  3.         //loc irownames `irownames' Item`i'
. 
. } // End of loop over item indices

. 
. // Column names for the item/rater summary matrices
. loc colnms Mean "Std Dev"

. 
. // Row names for the item summary matrix
. mat rownames items = `irownames'
Subtract and Simplify 7/10 - 13/25 invalid name
r(198);

end of do-file

r(198);

. h estout

